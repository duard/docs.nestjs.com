
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/kafka.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="kafka">Kafka</h3>
<p><a rel='nofollow' target='_blank' href="https://kafka.apache.org/">Kafka</a> is an open source, distributed streaming platform.</p>
<h4 appAnchor id="installation"><span>Installation</span></h4>
<p>Before we start, we have to install required package:</p>
<pre><code class="language-bash">
$ npm i --save kafkajs</code></pre>
<h4 appAnchor id="transporter"><span>Transporter</span></h4>
<p>In order to switch to <strong>Kafka</strong> transporter, we need to modify an options object passed to the <code>createMicroservice()</code> method.</p>

<span class="filename">
  {{ 'main' | extension: app62607e915590a0a8dca519aac6b519c4ce549ee4.isJsActive }}
<app-tabs #app62607e915590a0a8dca519aac6b519c4ce549ee4></app-tabs>
</span><pre><code class="language-typescript">
const app = await NestFactory.createMicroservice(ApplicationModule, &#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      brokers: [&#39;localhost:9092&#39;],
    &#125;
  &#125;,
&#125;);</code></pre><blockquote class="
info "><strong>Hint</strong> <code>Transport</code> enumerator is imported from the <code>@nestjs/microservices</code> package.
</blockquote>
<h4 appAnchor id="options"><span>Options</span></h4>
<p>There are a several options that determine the transporter&#39;s behavior.</p>
<table>
  <tr>
    <td><code>client</code></td>
    <td>Client configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/configuration"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>consumer</code></td>
    <td>Consumer configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/consuming#a-name-options-a-options"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>run</code></td>
    <td>Run configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/consuming"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>producer</code></td>
    <td>Producer configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/producing#options"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>send</code></td>
    <td>Send configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/producing#options"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
</table>

<h4 appAnchor id="client"><span>Client</span></h4>
<p>In order to create a client instance, we need to use <code>@Client()</code> decorator.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app403bb7ca3cb112b99120d364fba81ddc24755387.isJsActive }}
<app-tabs #app403bb7ca3cb112b99120d364fba81ddc24755387></app-tabs>
</span><pre><code class="language-typescript">
@Client(&#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      clientId: &#39;hero&#39;,
      brokers: [&#39;localhost:9092&#39;],
    &#125;,
    consumer: &#123;
      groupId: &#39;hero-consumer&#39;
    &#125;
  &#125;,
&#125;)
client: ClientKafka;</code></pre><p>There is a small difference compared to the previous examples. Instead of the <code>ClientProxy</code> class, we use the <code>ClientKafka</code> that provides a <code>subscribeToResponseOf()</code> method. The <code>subscribeToResponseOf()</code> method takes a request topic name as an argument and adds the derived reply topic name to a collection of reply topics.  This method is required when implementing the message pattern.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app159cd82a730624466e2b9416a39c3cf27fd57250.isJsActive }}
<app-tabs #app159cd82a730624466e2b9416a39c3cf27fd57250></app-tabs>
</span><pre><code class="language-typescript">
onModuleInit() &#123;
  this.client.subscribeToResponseOf(&#39;hero.kill.dragon&#39;);
&#125;</code></pre><p>If the <code>KafkaClient</code> is provided asynchronously to the controller, the <code>subscribeToResponseOf()</code> method must be called before calling the <code>connect()</code> method.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app3e11f84c4728f33691b86991e4710e5b30089bdc.isJsActive }}
<app-tabs #app3e11f84c4728f33691b86991e4710e5b30089bdc></app-tabs>
</span><pre><code class="language-typescript">
async onModuleInit() &#123;
  this.client.subscribeToResponseOf(&#39;hero.kill.dragon&#39;);
  await this.client.connect();
&#125;</code></pre><h4 appAnchor id="serialization"><span>Serialization</span></h4>
<h4 appAnchor id="naming-conventions"><span>Naming Conventions</span></h4>
<p>The Kafka microservice components append a description of their respective role onto the <code>client.clientId</code> and <code>consumer.groupId</code> options to prevent collisions between Nest microservice client and server components.  By default the <code>ClientKafka</code> components appends <code>-client</code> and the <code>ServerKafka</code> components appends <code>-server</code> to both of these options.</p>

<span class="filename">
  {{ 'main' | extension: app33e82457d6594e6a251fc5ba4fef3bad0d8f6d4e.isJsActive }}
<app-tabs #app33e82457d6594e6a251fc5ba4fef3bad0d8f6d4e></app-tabs>
</span><pre><code class="language-typescript">
const app = await NestFactory.createMicroservice(ApplicationModule, &#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      clientId: &#39;hero&#39;, // hero-server
      brokers: [&#39;localhost:9092&#39;],
    &#125;,
    consumer: &#123;
      groupId: &#39;hero-consumer&#39; // hero-consumer-server
    &#125;
  &#125;,
&#125;);</code></pre>
<span class="filename">
  {{ 'hero.controller' | extension: app21c7f4a8d2da7788e49356d2ccd4f55a6935c65e.isJsActive }}
<app-tabs #app21c7f4a8d2da7788e49356d2ccd4f55a6935c65e></app-tabs>
</span><pre><code class="language-typescript">
@Client(&#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      clientId: &#39;hero&#39;, // hero-client
      brokers: [&#39;localhost:9092&#39;],
    &#125;,
    consumer: &#123;
      groupId: &#39;hero-consumer&#39; // hero-consumer-client
    &#125;
  &#125;,
&#125;)
client: ClientKafka;</code></pre><blockquote class="
info "><strong>Hint</strong> Kafka client and consumer naming conventions can be customized by extending <code>KafkaClient</code> and <code>KafkaServer</code> in your own custom provider and overriding the constructor.
</blockquote>
<p>Since the Kafka microservice message pattern utilizes two topics for the request and reply channels, a reply pattern should be derived from the request topic.  By default, the name of reply topic is the composite of the request topic name with <code>.reply</code> appended.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app89508ee907d465e06d995b5d731c5837abf10b92.isJsActive }}
<app-tabs #app89508ee907d465e06d995b5d731c5837abf10b92></app-tabs>
</span><pre><code class="language-typescript">
onModuleInit() &#123;
  this.client.subscribeToResponseOf(&#39;hero.get&#39;); // entity.get.reply
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> Kafka reply topic naming conventions can be customized by extending <code>KafkaClient</code> in your own custom provider and overriding the <code>getResponsePatternName</code> method.
</blockquote>

</div>

