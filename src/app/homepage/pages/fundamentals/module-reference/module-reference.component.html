
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/module-reference.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="module-reference">Module reference</h3>
<p>Nest provides the <code>ModuleRef</code> class to navigate the internal list of providers and obtain a reference to any provider using its injection token as a lookup key. The <code>ModuleRef</code> class also provides a way to dynamically instantiate both static and scoped providers. <code>ModuleRef</code> can be injected into a class in the normal way:</p>

<span class="filename">
  {{ 'cats.service' | extension: app44ac784d1d3c9701b6cf13b8588300f3066c43d5.isJsActive }}
<app-tabs #app44ac784d1d3c9701b6cf13b8588300f3066c43d5></app-tabs>
</span><pre [class.hide]="app44ac784d1d3c9701b6cf13b8588300f3066c43d5.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService &#123;
  constructor(private readonly moduleRef: ModuleRef) &#123;&#125;
&#125;</code></pre>
<pre [class.hide]="!app44ac784d1d3c9701b6cf13b8588300f3066c43d5.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>ModuleRef</code> class is imported from the <code>@nestjs/core</code> package.
</blockquote>
<h4 appAnchor id="retrieving-provider-instances"><span>Retrieving provider instances</span></h4>
<p>The <code>ModuleRef</code> instance (hereafter we&#39;ll refer to it as the <strong>module reference</strong>) has a <code>get()</code> method. This method retrieves a provider that exists (has been injected) in the <strong>current</strong> module using the provider&#39;s injection token.</p>

<span class="filename">
  {{ 'cats.service' | extension: app4ac2f254f45bc1188b422e8e3263c4f464b162d7.isJsActive }}
<app-tabs #app4ac2f254f45bc1188b422e8e3263c4f464b162d7></app-tabs>
</span><pre [class.hide]="app4ac2f254f45bc1188b422e8e3263c4f464b162d7.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  private service: Service;
  constructor(private readonly moduleRef: ModuleRef) &#123;&#125;

  onModuleInit() &#123;
    this.service = this.moduleRef.get(Service);
  &#125;
&#125;</code></pre>
<pre [class.hide]="!app4ac2f254f45bc1188b422e8e3263c4f464b162d7.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  onModuleInit() &#123;
    this.service = this.moduleRef.get(Service);
  &#125;
&#125;</code></pre><blockquote class="
warning "><strong>Warning</strong> You can&#39;t retrieve scoped providers (transient or request-scoped) with the <code>get()</code> method. Instead, use the technique described <a href="https://docs.nestjs/com/fundamentals/module-ref#resolving-scoped-providers">below</a>. Learn how to control scopes <a routerLink="/fundamentals/injection-scopes">here</a>.
</blockquote>
<p>To retrieve a provider from the global context (for example, if the provider has been injected in a different module), pass the <code>{{ &#39;{&#39; }} strict: false {{ &#39;}&#39; }}</code> option as a second argument to <code>get()</code>.</p>
<pre><code class="language-typescript">
this.moduleRef.get(Service, &#123; strict: false &#125;);</code></pre>
<h4 appAnchor id="resolving-scoped-providers"><span>Resolving scoped providers</span></h4>
<p>To dynamically resolve a scoped provider (transient or request-scoped), use the <code>resolve()</code> method, passing the provider&#39;s injection token as an argument.</p>

<span class="filename">
  {{ 'cats.service' | extension: app9d824530126477596c50d5bc73f9a4ac477ed1e0.isJsActive }}
<app-tabs #app9d824530126477596c50d5bc73f9a4ac477ed1e0></app-tabs>
</span><pre [class.hide]="app9d824530126477596c50d5bc73f9a4ac477ed1e0.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  private transientService: TransientService;
  constructor(private readonly moduleRef: ModuleRef) &#123;&#125;

  async onModuleInit() &#123;
    this.transientService = await this.moduleRef.resolve(TransientService);
  &#125;
&#125;</code></pre>
<pre [class.hide]="!app9d824530126477596c50d5bc73f9a4ac477ed1e0.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  async onModuleInit() &#123;
    this.transientService = await this.moduleRef.resolve(TransientService);
  &#125;
&#125;</code></pre><p>The <code>resolve()</code> method returns a a unique instance of the provider, from its own <strong>DI container sub-tree</strong>. Each sub-tree has a unique <strong>context identifier</strong>. Thus, if you call this method more than once and compare instance references, you will see that they are not equal.</p>

<span class="filename">
  {{ 'cats.service' | extension: app7bc6967b70feac18eab77ef6c08216996cc8f67f.isJsActive }}
<app-tabs #app7bc6967b70feac18eab77ef6c08216996cc8f67f></app-tabs>
</span><pre [class.hide]="app7bc6967b70feac18eab77ef6c08216996cc8f67f.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  constructor(private readonly moduleRef: ModuleRef) &#123;&#125;

  async onModuleInit() &#123;
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService),
      this.moduleRef.resolve(TransientService),
    ]);
    console.log(transientServices[0] === transientServices[1]); // false
  &#125;
&#125;</code></pre>
<pre [class.hide]="!app7bc6967b70feac18eab77ef6c08216996cc8f67f.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  async onModuleInit() &#123;
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService),
      this.moduleRef.resolve(TransientService),
    ]);
    console.log(transientServices[0] === transientServices[1]); // false
  &#125;
&#125;</code></pre><p>To generate a single instance across multiple <code>resolve()</code> calls, and ensure they share the same generated DI container sub-tree, you can pass a context identifier to the <code>resolve()</code> method. Use the <code>ContextIdFactory</code> class to generate a context identifier. This class provides a <code>create()</code> method that returns an appropriate unique identifier.</p>

<span class="filename">
  {{ 'cats.service' | extension: app2cb592d91542a299b0149ada8ac62e3ced37f8f7.isJsActive }}
<app-tabs #app2cb592d91542a299b0149ada8ac62e3ced37f8f7></app-tabs>
</span><pre [class.hide]="app2cb592d91542a299b0149ada8ac62e3ced37f8f7.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  constructor(private readonly moduleRef: ModuleRef) &#123;&#125;

  async onModuleInit() &#123;
    const contextId = ContextIdFactory.create();
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService, contextId),
      this.moduleRef.resolve(TransientService, contextId),
    ]);
    console.log(transientServices[0] === transientServices[1]); // true
  &#125;
&#125;</code></pre>
<pre [class.hide]="!app2cb592d91542a299b0149ada8ac62e3ced37f8f7.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  async onModuleInit() &#123;
    const contextId = ContextIdFactory.create();
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService, contextId),
      this.moduleRef.resolve(TransientService, contextId),
    ]);
    console.log(transientServices[0] === transientServices[1]); // true
  &#125;
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>ContextIdFactory</code> class is imported from the <code>@nestjs/core</code> package.
</blockquote>
<h4 appAnchor id="getting-current-sub-tree"><span>Getting current sub-tree</span></h4>
<p>Occasionally, you may want to resolve an instance of a request-scoped provider within a <strong>request context</strong>. Let&#39;s say that <code>CatsService</code> is request-scoped and you want to resolve the <code>CatsRepository</code> instance which is also marked as a request-scoped provider. In order to share the same DI container sub-tree, you must obtain the current context identifier instead of generating a new one (e.g., with the <code>ContextIdFactory.create()</code> function, as shown above). To obtain the current context identifier, start by injecting the request object using <code>@Inject()</code> decorator.</p>

<span class="filename">
  {{ 'cats.service' | extension: app5dc8bffea1ab5a5febb1a9faf89f63c5db649252.isJsActive }}
<app-tabs #app5dc8bffea1ab5a5febb1a9faf89f63c5db649252></app-tabs>
</span><pre [class.hide]="app5dc8bffea1ab5a5febb1a9faf89f63c5db649252.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService &#123;
  constructor(
    @Inject(REQUEST) private readonly request: Record&lt;string, unknown&gt;,
  ) &#123;&#125;
&#125;</code></pre>
<pre [class.hide]="!app5dc8bffea1ab5a5febb1a9faf89f63c5db649252.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(REQUEST)
export class CatsService &#123;
  constructor(request) &#123;
    this.request = request;
  &#125;
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> Learn more about the request provider <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/fundamentals/injection-scopes#request-provider">here</a>.
</blockquote>
<p>Now, use the <code>getByRequest()</code> method of the <code>ContextIdFactory</code> class to create a context id based on the request object, and pass this to the <code>resolve()</code> call:</p>
<pre><code class="language-typescript">
const contextId = ContextIdFactory.getByRequest(this.request);
const catsRepository = await this.moduleRef.resolve(CatsRepository, contextId);</code></pre>
<h4 appAnchor id="instantiating-classes-dynamically"><span>Instantiating classes dynamically</span></h4>
<p>To dynamically instantiate a class that wasn&#39;t previously registered as a provider, use the module reference&#39;s <code>create()</code> method.</p>

<span class="filename">
  {{ 'cats.service' | extension: appb17f489b1ca5f0e36050a97979e4f09cf9b53833.isJsActive }}
<app-tabs #appb17f489b1ca5f0e36050a97979e4f09cf9b53833></app-tabs>
</span><pre [class.hide]="appb17f489b1ca5f0e36050a97979e4f09cf9b53833.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  private catsFactory: CatsFactory;
  constructor(private readonly moduleRef: ModuleRef) &#123;&#125;

  async onModuleInit() &#123;
    this.catsFactory = await this.moduleRef.create(CatsFactory);
  &#125;
&#125;</code></pre>
<pre [class.hide]="!appb17f489b1ca5f0e36050a97979e4f09cf9b53833.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  async onModuleInit() &#123;
    this.catsFactory = await this.moduleRef.create(CatsFactory);
  &#125;
&#125;</code></pre><p>This technique enables you to conditionally instantiate different classes outside of the framework container.</p>

</div>

