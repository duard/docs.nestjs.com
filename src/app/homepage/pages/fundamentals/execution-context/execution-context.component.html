
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/execution-context.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="execution-context">Execution context</h3>
<p>Nest provides several utility classes that help make it easy to write applications that function across multiple application contexts (e.g., Nest HTTP server-based, microservices and WebSockets application contexts). These utilities provide information about the current execution context which can be used to build generic <a routerLink="/guards">guards</a>, <a routerLink="/exception-filters">filters</a>, and <a routerLink="/interceptors">interceptors</a> that can work across a broad set of controllers, methods, and execution contexts.</p>
<p>We cover two such classes in this chapter: <code>ArgumentsHost</code> and <code>ExecutionContext</code>.</p>
<h4 appAnchor id="argumentshost-class"><span>ArgumentsHost class</span></h4>
<p>The <code>ArgumentsHost</code> class provides methods for retrieving the arguments being passed to a handler. It allows choosing the appropriate context (e.g., HTTP, RPC (microservice), or WebSockets) to retrieve the arguments from. The framework provides an instance of <code>ArgumentsHost</code>, typically referenced as a <code>host</code> parameter, in places where you may want to access it. For example, the <code>catch()</code> method of an <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/exception-filters#arguments-host">exception filter</a> is called with an <code>ArgumentsHost</code>instance.</p>
<p><code>ArgumentsHost</code> simply acts as an abstraction over a handler&#39;s arguments. For example, for HTTP server applications (when <code>@nestjs/platform-express</code> is being used), the <code>host</code> object encapsulates Express&#39;s <code>[request, response, next]</code> array, where <code>request</code> is the request object, <code>response</code> is the response object, and <code>next</code> is a function that controls the application&#39;s request-response cycle. On the other hand, for <a routerLink="/graphql/quick-start">GraphQL</a> applications, the <code>host</code> object contains the <code>[root, args, context, info]</code> array.</p>
<h4 appAnchor id="current-application-context"><span>Current application context</span></h4>
<p>When building generic <a routerLink="/guards">guards</a>, <a routerLink="/exception-filters">filters</a>, and <a routerLink="/interceptors">interceptors</a> which are meant to run across multiple application contexts, we need a way to determine the type of application that our method is currently running in. Do this with the <code>getType()</code> method of <code>ArgumentsHost</code>:</p>
<pre><code class="language-typescript">
const type = host.getType();
if (type === &#39;http&#39;) &#123;
  // HTTP application
&#125; else if (type === &#39;rpc&#39;) &#123;
  // Microservice
&#125;</code></pre>
<p>With the application type available, we can write more generic components, as shown below.</p>
<h4 appAnchor id="host-handler-arguments"><span>Host handler arguments</span></h4>
<p>To retrieve the array of arguments being passed to the handler, one approach is to use the host object&#39;s <code>getArgs()</code> method.</p>
<pre><code class="language-typescript">
const [req, res, next] = host.getArgs();</code></pre>
<p>You can pluck a particular argument by index using the <code>getArgByIndex()</code> method:</p>
<pre><code class="language-typescript">
const request = host.getArgByIndex(0);
const response = host.getArgByIndex(1);</code></pre>
<p>In these examples we retrieved the request and response objects by index, which is not typically recommended as it couples the application to a particular execution context. Instead, you can make your code more robust and reusable by using one of the <code>host</code> object&#39;s utility methods to switch to the appropriate application context for your application. The context switch utility methods are shown below.</p>
<pre><code class="language-typescript">
/**
 * Switch context to RPC.
 */
switchToRpc(): RpcArgumentsHost;
/**
 * Switch context to HTTP.
 */
switchToHttp(): HttpArgumentsHost;
/**
 * Switch context to WebSockets.
 */
switchToWs(): WsArgumentsHost;</code></pre>
<p>Let&#39;s rewrite the previous example using the <code>switchToHttp()</code> method. The <code>host.switchToHttp()</code> helper call returns an <code>HttpArgumentsHost</code> object that is appropriate for the HTTP application context. The <code>HttpArgumentsHost</code> object has two useful methods we can use to extract the desired objects. We also use the Express type assertions in this case to return native Express typed objects:</p>
<pre><code class="language-typescript">
const ctx = host.switchToHttp();
const request = ctx.getRequest&lt;Request&gt;();
const response = ctx.getResponse&lt;Response&gt;();</code></pre>
<p>Similarly, <code>RpcArgumentsHost</code> and <code>WsArgumentsHost</code> have methods to return appropriate objects in the microservices and WebSockets contexts.</p>
<pre><code class="language-typescript">
export interface WsArgumentsHost &#123;
  /**
   * Returns the data object.
   */
  getData&lt;T = any&gt;(): T;
  /**
   * Returns the client object.
   */
  getClient&lt;T = any&gt;(): T;
&#125;</code></pre>
<pre><code class="language-typescript">
export interface RpcArgumentsHost &#123;
  /**
   * Returns the data object.
   */
  getData&lt;T = any&gt;(): T;

  /**
   * Returns the context object.
   */
  getContext&lt;T = any&gt;(): T;
&#125;</code></pre>
<h4 appAnchor id="executioncontext-class"><span>ExecutionContext class</span></h4>
<p><code>ExecutionContext</code> extends <code>ArgumentsHost</code>, providing additional details about the current execution process. Like <code>ArgumentsHost</code>, Nest provides an instance of <code>ExecutionContext</code> in places you may need it, such as in the <code>canActivate()</code> method of a <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/guards#execution-context">guard</a> and the <code>intercept()</code> method of an <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/interceptors#execution-context">interceptor</a>. It provides the following methods:</p>
<pre><code class="language-typescript">
export interface ExecutionContext extends ArgumentsHost &#123;
  /**
   * Returns the type of the controller class which the current handler belongs to.
   */
  getClass&lt;T&gt;(): Type&lt;T&gt;;
  /**
   * Returns a reference to the handler (method) that will be invoked next in the
   * request pipeline.
   */
  getHandler(): Function;
&#125;</code></pre>
<p>The <code>getHandler()</code> method returns a reference to the handler about to be invoked. The <code>getClass()</code> method returns the type of the <code>Controller</code> class which this particular handler belongs to. For example, in an HTTP context, if the currently processed request is a <code>POST</code> request, bound to the <code>create()</code> method on the <code>CatsController</code>, <code>getHandler()</code> returns a reference to the <code>create()</code> method and <code>getClass()</code> returns the <code>CatsController</code> <strong>type</strong> (not instance).</p>
<pre><code class="language-typescript">
const methodKey = ctx.getHandler().name; // &quot;create&quot;
const className = ctx.getClass().name; // &quot;CatsController&quot;</code></pre>
<p>The ability to access references to both the current class and handler method provides great flexibility. Most importantly, it gives us the opportunity to access the metadata set through the <code>@SetMetadata()</code> decorator from within guards or interceptors. We cover this use case below.</p>
<h4 appAnchor id="reflection-and-metadata"><span>Reflection and metadata</span></h4>
<p>Nest provides the ability to attach <strong>custom metadata</strong> to route handlers through the <code>@SetMetadata()</code> decorator (read more about custom metadata <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/guards#reflection">here</a>). We can then access this metadata from within our class to make certain decisions.</p>

<span class="filename">
  {{ 'cats.controller' | extension: app589973ef0187b344e0a0aecaa345657a447d0966.isJsActive }}
<app-tabs #app589973ef0187b344e0a0aecaa345657a447d0966></app-tabs>
</span><pre [class.hide]="app589973ef0187b344e0a0aecaa345657a447d0966.isJsActive"><code class="language-typescript">
@Post()
@SetMetadata(&#39;roles&#39;, [&#39;admin&#39;])
async create(@Body() createCatDto: CreateCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;</code></pre>
<pre [class.hide]="!app589973ef0187b344e0a0aecaa345657a447d0966.isJsActive"><code class="language-typescript">
@Post()
@SetMetadata(&#39;roles&#39;, [&#39;admin&#39;])
@Bind(Body())
async create(createCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>@SetMetadata()</code> decorator is imported from the <code>@nestjs/common</code> package.
</blockquote>
<p>With the construction above, we attached the <code>roles</code> metadata (<code>roles</code> is a metadata key and <code>[&#39;admin&#39;]</code> is the associated value) to the <code>create()</code> method. While this works, it&#39;s not good practice to use <code>@SetMetadata()</code> directly in your routes. Instead, create your own decorators, as shown below:</p>

<span class="filename">
  {{ 'roles.decorator' | extension: appf36975e2194af02438f4ecb9343b079326214ca9.isJsActive }}
<app-tabs #appf36975e2194af02438f4ecb9343b079326214ca9></app-tabs>
</span><pre [class.hide]="appf36975e2194af02438f4ecb9343b079326214ca9.isJsActive"><code class="language-typescript">
import &#123; SetMetadata &#125; from &#39;@nestjs/common&#39;;

export const Roles = (...roles: string[]) =&gt; SetMetadata(&#39;roles&#39;, roles);</code></pre>
<pre [class.hide]="!appf36975e2194af02438f4ecb9343b079326214ca9.isJsActive"><code class="language-typescript">
import &#123; SetMetadata &#125; from &#39;@nestjs/common&#39;;

export const Roles = (...roles) =&gt; SetMetadata(&#39;roles&#39;, roles);</code></pre><p>This approach is much cleaner and more readable, and is strongly typed. Now that we have a custom <code>@Roles()</code> decorator, we can use it to decorate the <code>create()</code> method.</p>

<span class="filename">
  {{ 'cats.controller' | extension: app7c79ed68dc2f3373240fc9b6bd2bf21401b587f3.isJsActive }}
<app-tabs #app7c79ed68dc2f3373240fc9b6bd2bf21401b587f3></app-tabs>
</span><pre [class.hide]="app7c79ed68dc2f3373240fc9b6bd2bf21401b587f3.isJsActive"><code class="language-typescript">
@Post()
@Roles(&#39;admin&#39;)
async create(@Body() createCatDto: CreateCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;</code></pre>
<pre [class.hide]="!app7c79ed68dc2f3373240fc9b6bd2bf21401b587f3.isJsActive"><code class="language-typescript">
@Post()
@Roles(&#39;admin&#39;)
@Bind(Body())
async create(createCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;</code></pre><p>To access the route&#39;s role(s) (custom metadata), we&#39;ll use the <code>Reflector</code> helper class, which is provided out of the box by the framework and exposed from the <code>@nestjs/core</code> package. <code>Reflector</code> can be injected into a class in the normal way:</p>

<span class="filename">
  {{ 'roles.guard' | extension: app75aab9b6a00b89f8cdff2551725faffe3f5aa549.isJsActive }}
<app-tabs #app75aab9b6a00b89f8cdff2551725faffe3f5aa549></app-tabs>
</span><pre [class.hide]="app75aab9b6a00b89f8cdff2551725faffe3f5aa549.isJsActive"><code class="language-typescript">
@Injectable()
export class RolesGuard &#123;
  constructor(private readonly reflector: Reflector) &#123;&#125;
&#125;</code></pre>
<pre [class.hide]="!app75aab9b6a00b89f8cdff2551725faffe3f5aa549.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(Reflector)
export class CatsService &#123;
  constructor(reflector) &#123;
    this.reflector = reflector;
  &#125;
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>Reflector</code> class is imported from the <code>@nestjs/core</code> package.
</blockquote>
<p>Now, to read the handler metadata, use the <code>get()</code> method.</p>
<pre><code class="language-typescript">
const roles = this.reflector.get&lt;string[]&gt;(&#39;roles&#39;, context.getHandler());</code></pre>
<p>The <code>Reflector</code> class allows us to easily access the metadata by the specified <strong>key</strong> (in this case, the key is <code>&#39;roles&#39;</code>; refer back to the <code>roles.decorator.ts</code> file above and the <code>SetMetadata()</code> call made there). In this example, we passed <code>context.getHandler()</code> to extract the metadata for the currently processed request method. Remember, <code>getHandler()</code> gives us a <strong>reference</strong> to the route handler function.</p>
<p>We can make this guard more generic by extracting the <strong>controller metadata</strong> and using that to determine the current user role.</p>

<span class="filename">
  {{ 'cats.controller' | extension: appf40db1c62c193e926088ea5086a0eb58aa42b085.isJsActive }}
<app-tabs #appf40db1c62c193e926088ea5086a0eb58aa42b085></app-tabs>
</span><pre [class.hide]="appf40db1c62c193e926088ea5086a0eb58aa42b085.isJsActive"><code class="language-typescript">
@Roles(&#39;admin&#39;)
@Controller(&#39;cats&#39;)
export class CatsController &#123;&#125;</code></pre>
<pre [class.hide]="!appf40db1c62c193e926088ea5086a0eb58aa42b085.isJsActive"><code class="language-typescript">
@Roles(&#39;admin&#39;)
@Controller(&#39;cats&#39;)
export class CatsController &#123;&#125;</code></pre><p>Now, to extract controller metadata, we pass <code>context.getClass()</code> instead of <code>context.getHandler()</code>:</p>

<span class="filename">
<app-tabs #app7592bc3d0cafe5aafad4664a999c31292d960027></app-tabs>
</span><pre [class.hide]="app7592bc3d0cafe5aafad4664a999c31292d960027.isJsActive"><code class="language-typescript">
const roles = this.reflector.get&lt;string[]&gt;(&#39;roles&#39;, context.getClass());</code></pre>
<pre [class.hide]="!app7592bc3d0cafe5aafad4664a999c31292d960027.isJsActive"><code class="language-typescript">
const roles = this.reflector.get(&#39;roles&#39;, context.getClass());</code></pre><p>The <code>Reflector</code> class provides two other utility methods used to extract <strong>both</strong> controller and method metadata at once. This is helpful when, for example, default roles are set at the controller level, but overridden at the method (route) level.</p>
<p>To get metadata for both and merge it (this method merges both arrays and objects), use the <code>getAllAndMerge()</code> method:</p>
<pre><code class="language-typescript">
const roles = this.reflector.getAllAndMerge&lt;string[]&gt;(&#39;roles&#39;, [
  context.getHandler(),
  context.getClass(),
]);</code></pre>
<p>To get metadata for both and return the first <strong>defined</strong> value, use the <code>getAllAndOverride()</code> method:</p>
<pre><code class="language-typescript">
const roles = this.reflector.getAllAndOverride&lt;string[]&gt;(&#39;roles&#39;, [
  context.getHandler(),
  context.getClass(),
]);</code></pre>

</div>

