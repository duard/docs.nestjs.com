
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/kafka.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="kafka">Kafka</h3>
<p><a rel='nofollow' target='_blank' href="https://kafka.apache.org/">Kafka</a> is an open source, distributed streaming platform.</p>
<h4 appAnchor id="installation"><span>Installation</span></h4>
<p>Before we start, we have to install required package:</p>
<pre><code class="language-bash">
$ npm i --save kafkajs</code></pre>
<h4 appAnchor id="transporter"><span>Transporter</span></h4>
<p>In order to switch to <strong>Kafka</strong> transporter, we need to modify an options object passed to the <code>createMicroservice()</code> method.</p>

<span class="filename">
  {{ 'main' | extension: app04ede4a8dfc7c8230280fb6f2a7fb1fd85d5a1ec.isJsActive }}
<app-tabs #app04ede4a8dfc7c8230280fb6f2a7fb1fd85d5a1ec></app-tabs>
</span><pre><code class="language-typescript">
const app = await NestFactory.createMicroservice(ApplicationModule, &#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      brokers: [&#39;localhost:9092&#39;],
    &#125;
  &#125;
&#125;);</code></pre><blockquote class="
info "><strong>Hint</strong> <code>Transport</code> enumerator is imported from the <code>@nestjs/microservices</code> package.
</blockquote>
<h4 appAnchor id="options"><span>Options</span></h4>
<p>There are a several options that determine the transporter&#39;s behavior.</p>
<table>
  <tr>
    <td><code>client</code></td>
    <td>Client configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/configuration"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>consumer</code></td>
    <td>Consumer configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/consuming#a-name-options-a-options"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>run</code></td>
    <td>Run configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/consuming"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>producer</code></td>
    <td>Producer configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/producing#options"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>send</code></td>
    <td>Send configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/producing#options"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
</table>

<h4 appAnchor id="client"><span>Client</span></h4>
<p>In order to create a client instance, we need to use <code>@Client()</code> decorator.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app608f779c001dfae9dda0c4fbcda0720cc029ed7c.isJsActive }}
<app-tabs #app608f779c001dfae9dda0c4fbcda0720cc029ed7c></app-tabs>
</span><pre><code class="language-typescript">
@Client(&#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      clientId: &#39;hero&#39;,
      brokers: [&#39;localhost:9092&#39;],
    &#125;,
    consumer: &#123;
      groupId: &#39;hero-consumer&#39;
    &#125;
  &#125;
&#125;)
client: ClientKafka;</code></pre><p>There is a small difference compared to other microservices. Instead of the <code>ClientProxy</code> class, we use the <code>ClientKafka</code> that provides a <code>subscribeToResponseOf()</code> method. The <code>subscribeToResponseOf()</code> method takes a request topic name as an argument and adds the derived reply topic name to a collection of reply topics.  This method is required when implementing the message pattern.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app41a1f5aee8b9e5e7529fe2ecf71dd861c7fed916.isJsActive }}
<app-tabs #app41a1f5aee8b9e5e7529fe2ecf71dd861c7fed916></app-tabs>
</span><pre><code class="language-typescript">
onModuleInit() &#123;
  this.client.subscribeToResponseOf(&#39;hero.kill.dragon&#39;);
&#125;</code></pre><p>If the <code>ClientKafka</code> is provided asynchronously to the controller, the <code>subscribeToResponseOf()</code> method must be called before calling the <code>connect()</code> method.</p>

<span class="filename">
  {{ 'hero.controller' | extension: appe7f15f25c47a380cb10cd1411a239cc424da888c.isJsActive }}
<app-tabs #appe7f15f25c47a380cb10cd1411a239cc424da888c></app-tabs>
</span><pre><code class="language-typescript">
async onModuleInit() &#123;
  this.client.subscribeToResponseOf(&#39;hero.kill.dragon&#39;);
  await this.client.connect();
&#125;</code></pre><h4 appAnchor id="message-pattern"><span>Message Pattern</span></h4>
<p>The Kafka microservice message pattern utilizes two topics for the request and reply channels.  The <code>ClientKafka</code> sends messages with a <a rel='nofollow' target='_blank' href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/ReturnAddress.html">return address</a> by associating a <a rel='nofollow' target='_blank' href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html">correlation id</a>, reply topic, and reply partition with the request message.  This requires the <code>ClientKafka</code> instance to be subscribed to the reply topic and assigned to at least one partition before sending a message.</p>
<p>Subsequently, you need to have at least one reply topic partition for every Nest application running.  For example, if you are running 4 Nest applications but the reply topic only has 3 partitions then 1 of the Nest applications will error out when trying to send a message.</p>
<p>When new <code>ClientKafka</code> instances are launched they join the consumer group and ask for a partition.  This triggers a rebalance of partitions assigned to consumers belonging to the consumer group.  Normally, this would be done in a round robin partitioner that assigns topic partitions to a collection of consumers sorted by consumer names.  However, when using this partitioning method, a new consumer could join the consumer group and be placed anywhere within the collection of consumers sorted by consumer names because the consumer name is randomly set on application launch.  To circumvent this problem, the <code>ClientKafka</code> consumer uses round robin partitioner that assigns topic partitions to a collection of consumers sorted by a consumer&#39;s high-resolution timestamps (<code>process.hrtime()</code>) that is set on application launch.</p>
<h4 appAnchor id="incoming"><span>Incoming</span></h4>
<p>Nest receives incoming Kafka messages as an object with <code>key</code>, <code>value</code>, and <code>headers</code> properties that have values of the <code>Buffer</code> type.  Nest then parses these values by transforming the buffers into strings.  If the string is &quot;object like&quot;, Nest attempts to parse the string as <code>JSON</code>.  The parsed object is then passed to it&#39;s the associated handler with the following properties.</p>
<pre><code class="language-typescript">
interface IncomingMessage &#123;
  topic: string;
  partition: number;
  timestamp: string;
  size: number;
  attributes: number;
  offset: string;
  key: any;
  value: any;
  headers: Record&lt;string, any&gt;;
&#125;</code></pre>
<h4 appAnchor id="outgoing"><span>Outgoing</span></h4>
<p>Nest sends outgoing Kafka messages after a serialization process when publishing events or sending messages.  This occurs on arguments passed to the client <code>emit()</code> and <code>send()</code> methods or on values returned from a <code>@MessagePattern</code> method. This serialization &quot;stringifies&quot; objects that are not strings or buffers by using <code>JSON.stringify()</code> or the <code>toString()</code> prototype method.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app908300266243bab6ab4744d7c178d23f548a47bf.isJsActive }}
<app-tabs #app908300266243bab6ab4744d7c178d23f548a47bf></app-tabs>
</span><pre><code class="language-typescript">
@Controller()
export class HeroService &#123;
  @MessagePattern(&#39;hero.kill.dragon&#39;)
  killDragon(message: any): any &#123;
    const dragonId = message.value.dragonId;
    const items = [
      &#123; id: 1, name: &#39;Mythical Sword&#39; &#125;,
      &#123; id: 2, name: &#39;Key to Dungeon&#39; &#125;,
    ];

    return items;
  &#125;
&#125;</code></pre><p>Outgoing messages can also be keyed by passing an object with the <code>key</code> and <code>value</code> properties.  Keying messages is important for meeting the <a rel='nofollow' target='_blank' href="https://docs.confluent.io/current/ksql/docs/developer-guide/partition-data.html#co-partitioning-requirements">co-partitioning requirement</a>.</p>

<span class="filename">
  {{ 'hero.controller' | extension: appec9f4c46a78ce2e66b7181ad2aeddfd6d66dfba2.isJsActive }}
<app-tabs #appec9f4c46a78ce2e66b7181ad2aeddfd6d66dfba2></app-tabs>
</span><pre><code class="language-typescript">
@Controller()
export class HeroService &#123;
  @MessagePattern(&#39;hero.kill.dragon&#39;)
  killDragon(message: any): any &#123;
    const realm = &#39;Nest&#39;;
    const heroId = message.value.heroId;
    const dragonId = message.value.dragonId;

    const items = [
      &#123; id: 1, name: &#39;Mythical Sword&#39; &#125;,
      &#123; id: 2, name: &#39;Key to Dungeon&#39; &#125;,
    ];

    return &#123;
      headers: &#123;
        realm
      &#125;,
      key: heroId,
      value: items
    &#125;
  &#125;
&#125;</code></pre><p>Additionally, messages passed in this format can also contain custom headers set in the <code>headers</code> hash property.  Header hash property values must be either a type of <code>string</code> or <code>Buffer</code>.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app8d39109e7ffd15e67db9eb10f201228fbfb77e25.isJsActive }}
<app-tabs #app8d39109e7ffd15e67db9eb10f201228fbfb77e25></app-tabs>
</span><pre><code class="language-typescript">
@Controller()
export class HeroService &#123;
  @MessagePattern(&#39;hero.kill.dragon&#39;)
  killDragon(message: any): any &#123;
    const realm = &#39;Nest&#39;;
    const heroId = message.value.heroId;
    const dragonId = message.value.dragonId;

    const items = [
      &#123; id: 1, name: &#39;Mythical Sword&#39; &#125;,
      &#123; id: 2, name: &#39;Key to Dungeon&#39; &#125;,
    ];

    return &#123;
      headers: &#123;
        kafka_nestRealm: realm
      &#125;,
      key: heroId,
      value: items
    &#125;
  &#125;
&#125;</code></pre><h4 appAnchor id="naming-conventions"><span>Naming Conventions</span></h4>
<p>The Kafka microservice components append a description of their respective role onto the <code>client.clientId</code> and <code>consumer.groupId</code> options to prevent collisions between Nest microservice client and server components.  By default the <code>ClientKafka</code> components appends <code>-client</code> and the <code>ServerKafka</code> components appends <code>-server</code> to both of these options.</p>

<span class="filename">
  {{ 'main' | extension: app5bd89a7be8312ba9cdfa80139f2ba45293b062eb.isJsActive }}
<app-tabs #app5bd89a7be8312ba9cdfa80139f2ba45293b062eb></app-tabs>
</span><pre><code class="language-typescript">
const app = await NestFactory.createMicroservice(ApplicationModule, &#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      clientId: &#39;hero&#39;, // hero-server
      brokers: [&#39;localhost:9092&#39;],
    &#125;,
    consumer: &#123;
      groupId: &#39;hero-consumer&#39; // hero-consumer-server
    &#125;,
  &#125;
&#125;);</code></pre>
<span class="filename">
  {{ 'hero.controller' | extension: app2cac6b37813b1c039f99d4442515b93bc9ab2a8b.isJsActive }}
<app-tabs #app2cac6b37813b1c039f99d4442515b93bc9ab2a8b></app-tabs>
</span><pre><code class="language-typescript">
@Client(&#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      clientId: &#39;hero&#39;, // hero-client
      brokers: [&#39;localhost:9092&#39;],
    &#125;,
    consumer: &#123;
      groupId: &#39;hero-consumer&#39; // hero-consumer-client
    &#125;
  &#125;
&#125;)
client: ClientKafka;</code></pre><blockquote class="
info "><strong>Hint</strong> Kafka client and consumer naming conventions can be customized by extending <code>ClientKafka</code> and <code>KafkaServer</code> in your own custom provider and overriding the constructor.
</blockquote>
<p>Since the Kafka microservice message pattern utilizes two topics for the request and reply channels, a reply pattern should be derived from the request topic.  By default, the name of reply topic is the composite of the request topic name with <code>.reply</code> appended.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app9ac191d600c849dc2501ba6ba0a7fe7e3691d034.isJsActive }}
<app-tabs #app9ac191d600c849dc2501ba6ba0a7fe7e3691d034></app-tabs>
</span><pre><code class="language-typescript">
onModuleInit() &#123;
  this.client.subscribeToResponseOf(&#39;hero.get&#39;); // hero.get.reply
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> Kafka reply topic naming conventions can be customized by extending <code>ClientKafka</code> in your own custom provider and overriding the <code>getResponsePatternName</code> method.
</blockquote>

</div>

