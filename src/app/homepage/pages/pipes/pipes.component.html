<div class="content">
  <h3>Pipes</h3>
  <p>
    A pipe is a class with
    <code>@Pipe()</code> decorator. The pipe should implement the
    <code>PipeTransform</code> interface.
  </p>
  <figure>
    <img src="/assets/Pipe_1.png" />
  </figure>
  <p>
    A pipe
    <strong>transforms</strong> the input data to the desired output. Also, it could take care of the
    <strong>validation</strong>, since it's possible to throw an exception when the data is incorrect.
  </p>
  <blockquote>
    <strong>Hint</strong> The pipe runs inside the exceptions zone. This means that when exceptions are thrown they are handled by the core exceptions
    handler and
    <a routerLink="/exception-filters">exceptions filters</a> that are applied to the current context.
  </blockquote>
  <h4>Built-in pipes</h4>
  <p>
    Nest comes with two pipes available right out-of-the-box,
    <code>ValidationPipe</code> and
    <code>ParseIntPipe</code>. They're exported from the
    <code>@nestjs/common</code> package. In order to better understand how do they work, we're gonna build them from scratch.
  </p>
  <h4>What does it look like?</h4>
  <p>
    Let's start with the
    <code>ValidationPipe</code>. Now it only takes a value and immediately returns the same value, behaving like an identity function.
  </p>
  <span class="filename">validation.pipe.ts</span>
  <pre><code class="language-typescript">{{ validationPipe }}</code></pre>
  <blockquote>
    <strong>Notice</strong> The
    <code>ValidationPipe</code> works only with
    <strong>TypeScript</strong>. If you use vanilla JavaScript, I'd recommend using the
    <a href="https://github.com/hapijs/joi"
      target="blank">Joi</a> library.
  </blockquote>
  <p>
    Every pipe has to provide the
    <code>transform()</code> method. This method takes two arguments:
  </p>
  <ul>
    <li>
      <code>value</code>
    </li>
    <li>
      <code>metadata</code>
    </li>
  </ul>
  <p>
    The
    <code>value</code> is the currently processed parameter, while
    <code>metadata</code> is its metadata. The metadata object holds a few properties:
  </p>
  <pre><code class="language-typescript">{{ argumentMetadata }}</code></pre>
  <p>
    These properties describe the input parameter.
  </p>
  <table>
    <tr>
      <td>
        <code>type</code>
      </td>
      <td>Tells us whether the property is a body
        <code>@Body()</code>, query
        <code>@Query()</code>, param
        <code>@Param()</code>, or a custom parameter (read more
        <a routerLink="/custom-decorators">here</a>).</td>
    </tr>
    <tr>
      <td>
        <code>metatype</code>
      </td>
      <td>
        The metatype of the property, for example
        <code>String</code>. It's
        <code>undefined</code> if you omit the type declaration in the function signature.
      </td>
    </tr>
    <tr>
      <td>
        <code>data</code>
      </td>
      <td>The string passed to the decorator, for example
        <code>@Body('string')</code>. It's
        <code>undefined</code> if you leave the brackets empty.</td>
    </tr>
  </table>
  <blockquote>
    <strong>Notice</strong> The TypeScript interfaces disappear during the transpilation. Hence, if you use an interface instead of a class,
    the
    <code>metatype</code> value will be equal to
    <code>Object</code>.
  </blockquote>
  <h4>What's the point?</h4>
  <p>
    Let's focus on the
    <code>create()</code> method of the
    <code>CatsController</code> for a while.
  </p>
  <span class="filename">cats.controler.ts</span>
  <pre><code class="language-typescript">{{ createCatsController }}</code></pre>
  <p>
    There's a
    <code>CreateCatDto</code> body parameter.
  </p>
  <span class="filename">create-cat.dto.ts</span>
  <pre><code class="language-typescript">{{ createCatDto }}</code></pre>
  <p>
    This object always has to be correct, and thus we have to validate these three members. We could do this inside the route handler
    method, but we'd break the
    <strong>single responsibility rule</strong> (SRP). The second idea is to create a
    <strong>validator class</strong> and delegate the task there, but we'll have to use this validator every time at the beginning
    of the method. So what about the validation middleware? It's a good idea, but it's not possible to create a
    <strong>generic middleware</strong> which could be used across the whole application.
  </p>
  <p>
    That's the first use-case, when you should consider to use a
    <strong>Pipe</strong>.
  </p>
  <h4>Class validator</h4>
  <h5>This section applies only to TypeScript.</h5>
  <p>
    Nest works well with the
    <a href="https://github.com/pleerock/class-validator" target="blank">class-validator</a>, this amazing library allows you to use decorator-based validation. Decorator based validation is
    really powerful with the
    <strong>pipe</strong> capabilities since we have access to the
    <code>metatype</code> of the processed property. Let's add a few decorators to the
    <code>CreateCatDto</code>.
  </p>
  <span class="filename">create-cat.dto.ts</span>
  <pre><code class="language-typescript">{{ createCatDtoValidation }}</code></pre>
  <p>
    Now it's time to finish the
    <code>ValidationPipe</code> class.
  </p>
  <span class="filename">validation.pipe.ts</span>
  <pre><code class="language-typescript">{{ fullValidationPipe }}</code></pre>
  <blockquote>
    <strong>Notice</strong> We've used the
    <a href="https://github.com/pleerock/class-transformer">class-transformer</a> library. It's made by the same author as the
    <strong>class-validator</strong> library, and as a result, they play well together.
  </blockquote>
  <p>
    Let's go through this code. Firstly, note that the
    <code>transform()</code> function is
    <code>async</code>. It's possible because Nest supports both synchronous and
    <strong>asynchronous</strong> pipes. Also, there's a helper function -
    <code>toValidate()</code>. It's responsible for excluding the native JavaScript types from the validation process. The last
    worth mentioning part is that we have to return the same value. This pipe is a validation specific pipe, so we need to return
    the exact same property to avoid
    <strong>overriding</strong> (as noted earlier, pipe transforms input to the desired output).
  </p>
  <p>
    The last step is to set up the
    <code>ValidationPipe</code>. Pipes, same as
    <a routerLink="/exception-filters">exception filters</a> can be method-scoped, controller-scoped, and global-scoped. Additionally, a pipe may be param-scoped.
    We can directly tie the pipe instance to the route param decorator, for example
    <code>@Body()</code>. Let's have a look at the below example:
  </p>
  <span class="filename">cats.controler.ts</span>
  <pre><code class="language-typescript">{{ createCatsControllerParamPipe }}</code></pre>
  <p>
    The param-scoped pipes are useful when the validation logic concerns only one, specified parameter. In order to set up a pipe at a method
    level, you'll need the
    <code>UsePipes()</code> decorator.
  </p>
  <span class="filename">cats.controler.ts</span>
  <pre><code class="language-typescript">{{ createCatsControllerMethodPipe }}</code></pre>
  <blockquote>
    <strong>Notice</strong> The
    <code>@UsePipes()</code> decorator is imported from the
    <code>@nestjs/common</code> package.
  </blockquote>
  <p>
    The instance of
    <code>ValidationPipe</code> has been created immedietely in-place. Another available way is to pass the class (not instance), leaving framework the instantiation
    responsibility and enabling
    <strong>dependency injection</strong>.
  </p>
  <span class="filename">cats.controler.ts</span>
  <pre><code class="language-typescript">{{ createCatsControllerMethodPipeClass }}</code></pre>
  <blockquote class="info">
      <strong>Hint</strong> Prefer applying classes instead of instances when possible. It reduces
      <strong>memory usage</strong> since Nest can easily reuse instances of the same class across your whole application.
    </blockquote>
  <p>
    Since the
    <code>ValidationPipe</code> was created to be as generic as possible, we're gonna set it up as a
    <strong>global-scoped</strong> pipe, for every route handler across the entire application.
  </p>
  <span class="filename">main.ts</span>
  <pre><code class="language-typescript">{{ globalPipe }}</code></pre>
  <blockquote>
    <strong>Notice</strong> The
    <code>useGlobalPipes()</code> method doesn't setup pipes for gateways and micro services.
  </blockquote>
  <h4>Transformer Pipe</h4>
  <p>
    Validation isn't the sole use case. At the beginning of this chapter, we have mentioned that a pipe can also
    <strong>transform</strong> the input data to the desired output. It's true because the value returned from the
    <code>transform</code> function completely overrides the previous value of the argument. Sometimes the data passed from the
    client needs to undergo some changes. Also, some parts could be missed, so we must apply the default values. The
    <strong>transformer pipes</strong> fill the gap between the request of the client and the request handler.
  </p>
  <span class="filename">
    {{ 'parse-int.pipe' | extension: parseIntPipeT.isJsActive }}
    <app-tabs #parseIntPipeT></app-tabs>
  </span>
  <pre [class.hide]="parseIntPipeT.isJsActive"><code class="language-typescript">{{ parseIntPipe }}</code></pre>
  <pre [class.hide]="!parseIntPipeT.isJsActive"><code class="language-typescript">{{ parseIntPipeJs }}</code></pre>
  <p>
    Here's a
    <code>ParseIntPipe</code> which is responsible for parsing a string into an integer value. We can simply tie a pipe to the selected
    param:
  </p>
  <span class="filename">
    <app-tabs #bindParamT></app-tabs>
  </span>
  <pre [class.hide]="bindParamT.isJsActive"><code class="language-typescript">{{ bindParam }}</code></pre>
  <pre [class.hide]="!bindParamT.isJsActive"><code class="language-typescript">{{ bindParamJs }}</code></pre>
  <p>
    Thanks to the above construction, <code>ParseIntPipe</code> will be executed before request even touches the corresponding handler.
  </p>
</div>
