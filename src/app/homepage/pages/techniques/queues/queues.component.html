
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/queues.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="queues">Queues</h3>
<p>Queues allow you to defer the processing of a time consuming task, such as audio transcoding or sending an email, until a later time. For queues, Nest provides integration with <a rel='nofollow' target='_blank' href="https://github.com/OptimalBits/bull">Bull</a> package out-of-the box with <code>@nestjs/bull</code>, which we&#39;ll cover in the current chapter. Bull is a Redis-based queue for Node.js carefully written for rock solid stability and atomicity.</p>
<h4 appAnchor id="installation"><span>Installation</span></h4>
<p>To begin using it, we first install the required dependencies.</p>
<pre><code class="language-bash">
$ npm install --save @nestjs/bull bull
$ npm install --save-dev @types/bull</code></pre>
<p>Once the installation process is complete, we can import the <code>BullModule</code> into the root <code>AppModule</code>.</p>

<span class="filename">
  {{ 'app.module' | extension: appad5fc6777a1b8c9d6b5db83686c723ce03f46388.isJsActive }}
<app-tabs #appad5fc6777a1b8c9d6b5db83686c723ce03f46388></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; BullModule &#125; from &#39;@nestjs/bull&#39;;

@Module(&#123;
  imports: [
    BullModule.registerQueue(&#123;
      name: &#39;audio&#39;,
      redis: &#123;
        host: &#39;localhost&#39;,
        port: 6379,
      &#125;,
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;</code></pre><p>The <code>registerQueue()</code> method allows to create either single or multiple queues at once based on the configuration objects. The configuration object will be passed down into the <code>Queue</code> constructor from the Bull package (read more <a rel='nofollow' target='_blank' href="https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#queue">here</a>). Here, we assumed that Redis database is listening on host <code>localhost</code> and port <code>6379</code> (the default settings).</p>
<p>Every <code>BullModule.registerQueue()</code> call will create a new queue referred by its instantiation name (the <code>name</code> property). Queue can have many producers, many consumers, and many listeners. Also, you can have one or more workers consuming jobs from the queue, which will consume the jobs in a given order: FIFO (the default), LIFO or according to priorities.</p>
<h4 appAnchor id="producers"><span>Producers</span></h4>
<p>To add a job to a queue, first inject the queue as follows:</p>
<pre><code class="language-typescript">
import &#123; Injectable &#125; from &#39;@nestjs/common&#39;;
import &#123; Queue &#125; from &#39;bull&#39;;
import &#123; InjectQueue &#125; from &#39;@nestjs/bull&#39;;

@Injectable()
export class AudioService &#123;
  constructor(@InjectQueue(&#39;audio&#39;) private readonly audioQueue: Queue) &#123;&#125;
&#125;</code></pre>
<blockquote class="
info "><strong>Hint</strong> Notice that we are referring the queue by its instantiation name <code>audio</code>.
</blockquote>
<p>Now, call <code>add()</code> method with the job details as an argument.</p>
<pre><code class="language-typescript">
const job = await this.audioQueue.add(&#123;
  foo: &#39;bar&#39;,
&#125;);</code></pre>
<p>Jobs are represented as serializable, JavaScript objects (since that is how they are going to be stored in Redis database).</p>
<h4 appAnchor id="consumers"><span>Consumers</span></h4>
<p>A consumer processes jobs added into the queue. In order to define a consumer class, use the <code>@Processor()</code> decorator as follows:</p>
<pre><code class="language-typescript">
import &#123; Processor &#125; from &#39;@nestjs/bull&#39;;

@Processor(&#39;audio&#39;)
export class AudioConsumer &#123;&#125;</code></pre>
<p>Where <code>audio</code> is the name of the queue.</p>
<p>Now, define a job listener inside the <code>AudioConsumer</code> class:</p>
<pre><code class="language-typescript">
import &#123; Processor, Process &#125; from &#39;@nestjs/bull&#39;;
import &#123; Job &#125; from &#39;bull&#39;;

@Processor(&#39;audio&#39;)
export class AudioConsumer &#123;
  @Process()
  async transcode(job: Job&lt;unknown&gt;) &#123;
    let progress = 0;
    for (i = 0; i &lt; 100; i++) &#123;
      await doSomething(job.data);
      progress += 10;
      job.progress(progress);
    &#125;
    return &#123;&#125;;
  &#125;
&#125;</code></pre>
<p>The <code>transcode</code> function will be called every time the worker is idling and there are jobs to process in the queue. The value returned by your process function will be stored in the jobs object and can be accessed later on, for example in a listener for the completed event.</p>
<h4 appAnchor id="event-listeners"><span>Event listeners</span></h4>
<p>Bull generates a set of useful events. Events can be local for a given queue instance or global. In order to listen to emitted events, use the dedicated decorators:</p>
<pre><code class="language-typescript">
@OnQueueActive()
onActive(job: Job) &#123;
  console.log(
    `Processing job $&#123;job.id&#125; of type $&#123;job.name&#125; with data $&#123;job.data&#125;...`,
  );
&#125;</code></pre>
<p>Nest provides a set of decorators that allow subscribing to some standard events. These are exposed from the <code>@nestjs/bull</code> package:</p>
<ul>
<li><code>@OnQueueError()</code></li>
<li><code>@OnQueueWaiting()</code></li>
<li><code>@OnQueueActive()</code></li>
<li><code>@OnQueueStalled()</code></li>
<li><code>@OnQueueProgress()</code></li>
<li><code>@OnQueueCompleted()</code></li>
<li><code>@OnQueueFailed()</code></li>
<li><code>@OnQueuePaused()</code></li>
<li><code>@OnQueueResumed()</code></li>
<li><code>@OnQueueCleaned()</code></li>
<li><code>@OnQueueDrained()</code></li>
<li><code>@OnQueueRemoved()</code></li>
<li><code>@OnGlobalQueueError()</code></li>
<li><code>@OnGlobalQueueWaiting()</code></li>
<li><code>@OnGlobalQueueActive()</code></li>
<li><code>@OnGlobalQueueStalled()</code></li>
<li><code>@OnGlobalQueueProgress()</code></li>
<li><code>@OnGlobalQueueCompleted()</code></li>
<li><code>@OnGlobalQueueFailed()</code></li>
<li><code>@OnGlobalQueuePaused()</code></li>
<li><code>@OnGlobalQueueResumed()</code></li>
<li><code>@OnGlobalQueueCleaned()</code></li>
<li><code>@OnGlobalQueueDrained()</code></li>
<li><code>@OnGlobalQueueRemoved()</code></li>
</ul>
<p>You can also use <code>@OnQueueEvent()</code> in combination with either <code>BullQueueEvents</code> and <code>BullQueueGlobalEvents</code> enums. Read more about events <a rel='nofollow' target='_blank' href="https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#events">here</a>.</p>
<h4 appAnchor id="named-jobs"><span>Named jobs</span></h4>
<p>Jobs may have unique names that can be used for clearer code.</p>
<pre><code class="language-typescript">
const job = await this.audioQueue.add(&#39;transcode&#39;, &#123;
  foo: &#39;bar&#39;,
&#125;);</code></pre>
<p>And on the consumer side:</p>
<pre><code class="language-typescript">
@Process(&#39;transcode&#39;)
async transcode(job: Job&lt;unknown&gt;) &#123; ... &#125;</code></pre>
<h4 appAnchor id="job-options"><span>Job options</span></h4>
<p>To delay the job a certain amount of time before it will be processed, use the <code>delay</code> configuration property.</p>
<pre><code class="language-typescript">
const job = await this.audioQueue.add(
  &#123;
    foo: &#39;bar&#39;,
  &#125;,
  &#123; delay: 3000 &#125;, // 3 seconds delayed
);</code></pre>
<p>To use <strong>LIFO</strong> (Last In First Out) mode, set the <code>lifo</code> property of the configuration object to <code>true</code>.</p>
<pre><code class="language-typescript">
const job = await this.audioQueue.add(
  &#123;
    foo: &#39;bar&#39;,
  &#125;,
  &#123; lifo: true &#125;,
);</code></pre>
<p>To prioritize jobs, use the <code>priority</code> property as follows:</p>
<pre><code class="language-typescript">
const job = await this.audioQueue.add(
  &#123;
    foo: &#39;bar&#39;,
  &#125;,
  &#123; priority: 2 &#125;,
);</code></pre>
<blockquote class="
info "><strong>Hint</strong> Highest priority is 1, and lower the larger integer you use.
</blockquote>
<blockquote class="
warning "><strong>Warning</strong> Priority queues are a bit slower than a standard queue.
</blockquote>
<h4 appAnchor id="pause--resume"><span>Pause &amp; resume</span></h4>
<p>You can pause and resume your queues. A paused queue will not process new jobs until resumed, but current jobs being processed will continue until they are finalized.</p>
<pre><code class="language-typescript">
await job.pause();</code></pre>
<p>In order to resume a paused queue, use the <code>resume()</code> method, as follows:</p>
<pre><code class="language-typescript">
await job.resume();</code></pre>
<h4 appAnchor id="reference"><span>Reference</span></h4>
<p>For more information and examples, we recommend looking at the official <a rel='nofollow' target='_blank' href="https://github.com/OptimalBits/bull/blob/master/REFERENCE.md#events">REFERENCE</a> document</p>
<h4 appAnchor id="async-configuration"><span>Async configuration</span></h4>
<p>You may want to pass your queue options asynchronously instead of statically. In this case, use the <code>registerQueueAsync()</code> method, which provides several ways to deal with async configuration.</p>
<p>One approach is to use a factory function:</p>
<pre><code class="language-typescript">
BullModule.registerQueueAsync(&#123;
  useFactory: () =&gt; (&#123;
    redis: &#123;
      host: &#39;localhost&#39;,
      port: 6379,
    &#125;,
  &#125;),
&#125;);</code></pre>
<p>Our factory behaves like any other <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/fundamentals/async-providers">asynchronous provider</a> (e.g., it can be <code>async</code> and it&#39;s able to inject dependencies through <code>inject</code>).</p>
<pre><code class="language-typescript">
BullModule.registerQueueAsync(&#123;
  imports: [ConfigModule],
  useFactory: async (configService: ConfigService) =&gt; (&#123;
    redis: &#123;
      host: configService.get(&#39;QUEUE_HOST&#39;),
      port: +configService.get(&#39;QUEUE_PORT&#39;),
    &#125;,
  &#125;),
  inject: [ConfigService],
&#125;);</code></pre>
<p>Alternatively, you can use the <code>useClass</code> syntax:</p>
<pre><code class="language-typescript">
BullModule.registerQueueAsync(&#123;
  useClass: BullConfigService,
&#125;);</code></pre>
<p>The construction above will instantiate <code>BullConfigService</code> inside <code>BullModule</code> and use it to provide an options object by calling <code>createBullOptions()</code>. Note that this means that the <code>BullConfigService</code> has to implement the <code>BullOptionsFactory</code> interface, as shown below:</p>
<pre><code class="language-typescript">
@Injectable()
class BullConfigService implements BullOptionsFactory &#123;
  createBullOptions(): BullModuleOptions &#123;
    return &#123;
      redis: &#123;
        host: &#39;localhost&#39;,
        port: 6379,
      &#125;,
    &#125;;
  &#125;
&#125;</code></pre>
<p>In order to prevent the creation of <code>BullConfigService</code> inside <code>BullModule</code> and use a provider imported from a different module, you can use the <code>useExisting</code> syntax.</p>
<pre><code class="language-typescript">
BullModule.registerQueueAsync(&#123;
  imports: [ConfigModule],
  useExisting: ConfigService,
&#125;);</code></pre>
<p>This construction works the same as <code>useClass</code> with one critical difference - <code>BullModule</code> will lookup imported modules to reuse an existing <code>ConfigService</code> instead of instantiating a new one.</p>
<h4 appAnchor id="example"><span>Example</span></h4>
<p>A working example is available <a rel='nofollow' target='_blank' href="https://github.com/nestjs/nest/tree/master/sample/26-queues">here</a>.</p>

</div>

