
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/microservices/kafka.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="kafka">Kafka</h3>
<p><a rel='nofollow' target='_blank' href="https://kafka.apache.org/">Kafka</a> is an open source, distributed streaming platform.</p>
<h4 appAnchor id="installation"><span>Installation</span></h4>
<p>First we need to install the required packages.</p>
<pre><code class="language-bash">
$ npm i --save kafkajs</code></pre>
<h4 appAnchor id="transporter"><span>Transporter</span></h4>
<p>To use the <strong>Kafka</strong> transporter, we need to pass an <code>options</code> object to the <code>createMicroservice()</code> method.</p>

<span class="filename">
  {{ 'main' | extension: app7ec11bd37a6a3ebed04651f133b407db2e287368.isJsActive }}
<app-tabs #app7ec11bd37a6a3ebed04651f133b407db2e287368></app-tabs>
</span><pre><code class="language-typescript">
const app = await NestFactory.createMicroservice(ApplicationModule, &#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      brokers: [&#39;localhost:9092&#39;],
    &#125;
  &#125;
&#125;);</code></pre><blockquote class="
info "><strong>Hint</strong> <code>Transport</code> enum is imported from the <code>@nestjs/microservices</code> package.
</blockquote>
<h4 appAnchor id="options"><span>Options</span></h4>
<p>There are several options that determine the transporter&#39;s behavior.</p>
<table>
  <tr>
    <td><code>client</code></td>
    <td>Client configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/configuration"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>consumer</code></td>
    <td>Consumer configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/consuming#a-name-options-a-options"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>run</code></td>
    <td>Run configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/consuming"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>producer</code></td>
    <td>Producer configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/producing#options"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
  <tr>
    <td><code>send</code></td>
    <td>Send configuration options. They are well-described
      <a
        href="https://kafka.js.org/docs/producing#options"
        rel="nofollow"
        target="blank"
        >here</a
      >.</td>
  </tr>
</table>

<h4 appAnchor id="client"><span>Client</span></h4>
<p>To create a client instance, we use the <code>@Client()</code> decorator.</p>

<span class="filename">
  {{ 'hero.controller' | extension: appcd9e19c4a386416d966bac2348aa9b501fac4947.isJsActive }}
<app-tabs #appcd9e19c4a386416d966bac2348aa9b501fac4947></app-tabs>
</span><pre><code class="language-typescript">
@Client(&#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      clientId: &#39;hero&#39;,
      brokers: [&#39;localhost:9092&#39;],
    &#125;,
    consumer: &#123;
      groupId: &#39;hero-consumer&#39;
    &#125;
  &#125;
&#125;)
client: ClientKafka;</code></pre><p>There is a small difference compared to the previous examples. Instead of the <code>ClientProxy</code> class, we use the <code>ClientKafka</code> class, which provides a <code>subscribeToResponseOf()</code> method. The <code>subscribeToResponseOf()</code> method takes a request topic name as an argument and adds the derived reply topic name to a collection of reply topics. This method is required when implementing the message pattern.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app7d373f5eadee7c0ad20ccc34e497f1a8c8003fe0.isJsActive }}
<app-tabs #app7d373f5eadee7c0ad20ccc34e497f1a8c8003fe0></app-tabs>
</span><pre><code class="language-typescript">
onModuleInit() &#123;
  this.client.subscribeToResponseOf(&#39;hero.kill.dragon&#39;);
&#125;</code></pre><p>If the <code>ClientKafka</code> is provided asynchronously to the controller, the <code>subscribeToResponseOf()</code> method must be called before calling the <code>connect()</code> method.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app04b0b63743f9f48722f6b76b2f75f28e8fbcec38.isJsActive }}
<app-tabs #app04b0b63743f9f48722f6b76b2f75f28e8fbcec38></app-tabs>
</span><pre><code class="language-typescript">
async onModuleInit() &#123;
  this.client.subscribeToResponseOf(&#39;hero.kill.dragon&#39;);
  await this.client.connect();
&#125;</code></pre><h4 appAnchor id="message-pattern"><span>Message pattern</span></h4>
<p>The Kafka microservice message pattern utilizes two topics for the request and reply channels. The <code>ClientKafka</code> sends messages with a <a rel='nofollow' target='_blank' href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/ReturnAddress.html">return address</a> by associating a <a rel='nofollow' target='_blank' href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html">correlation id</a>, reply topic, and reply partition with the request message. This requires the <code>ClientKafka</code> instance to be subscribed to the reply topic and assigned to at least one partition before sending a message.</p>
<p>Subsequently, you need to have at least one reply topic partition for every Nest application running. For example, if you are running 4 Nest applications but the reply topic only has 3 partitions, then 1 of the Nest applications will error out when trying to send a message.</p>
<p>When new <code>ClientKafka</code> instances are launched they join the consumer group and subscribe to their respective topics.  This process triggers a rebalance of topic partitions assigned to consumers of the consumer group.</p>
<p>Normally, topic partitions are assigned using round robin partitioner that assigns topic partitions to a collection of consumers sorted by consumer names which are randomly set on application launch.  However, when a new consumer joins the consumer group, the new consumer be positioned anywhere within the collection of consumers.  This creates a condition where preexisting consumers would be assigned different partitions when the preexisting consumer is positioned after the new consumer.  Subsequently, the consumers that are assigned different partitions will lose response messages of requests sent before the rebalance.</p>
<p>To prevent the <code>ClientKafka</code> consumers from losing response messages a custom partitioner is utilized.  This custom partitioner assigns partitions to a collection of consumers sorted by high-resolution timestamps (<code>process.hrtime()</code>) that are set on application launch.</p>
<h4 appAnchor id="incoming"><span>Incoming</span></h4>
<p>Nest receives incoming Kafka messages as an object with <code>key</code>, <code>value</code>, and <code>headers</code> properties that have values of the <code>Buffer</code> type. Nest then parses these values by transforming the buffers into strings. If the string is &quot;object like&quot;, Nest attempts to parse the string as <code>JSON</code>. The parsed object is then passed to its associated handler with the following properties.</p>
<pre><code class="language-typescript">
interface IncomingMessage &#123;
  topic: string;
  partition: number;
  timestamp: string;
  size: number;
  attributes: number;
  offset: string;
  key: any;
  value: any;
  headers: Record&lt;string, any&gt;;
&#125;</code></pre>
<h4 appAnchor id="outgoing"><span>Outgoing</span></h4>
<p>Nest sends outgoing Kafka messages after a serialization process when publishing events or sending messages. This occurs on arguments passed to the client <code>emit()</code> and <code>send()</code> methods or on values returned from a <code>@MessagePattern</code> method. This serialization &quot;stringifies&quot; objects that are not strings or buffers by using <code>JSON.stringify()</code> or the <code>toString()</code> prototype method.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app544780b5ad46780aa6b483ce99a1514aba584712.isJsActive }}
<app-tabs #app544780b5ad46780aa6b483ce99a1514aba584712></app-tabs>
</span><pre><code class="language-typescript">
@Controller()
export class HeroService &#123;
  @MessagePattern(&#39;hero.kill.dragon&#39;)
  killDragon(message: any): any &#123;
    const dragonId = message.value.dragonId;
    const items = [
      &#123; id: 1, name: &#39;Mythical Sword&#39; &#125;,
      &#123; id: 2, name: &#39;Key to Dungeon&#39; &#125;,
    ];

    return items;
  &#125;
&#125;</code></pre><p>Outgoing messages can also be keyed by passing an object with the <code>key</code> and <code>value</code> properties. Keying messages is important for meeting the <a rel='nofollow' target='_blank' href="https://docs.confluent.io/current/ksql/docs/developer-guide/partition-data.html#co-partitioning-requirements">co-partitioning requirement</a>.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app3dda7fa0d1b291bf3c097207ec7c2bc4bbac3a39.isJsActive }}
<app-tabs #app3dda7fa0d1b291bf3c097207ec7c2bc4bbac3a39></app-tabs>
</span><pre><code class="language-typescript">
@Controller()
export class HeroService &#123;
  @MessagePattern(&#39;hero.kill.dragon&#39;)
  killDragon(message: any): any &#123;
    const realm = &#39;Nest&#39;;
    const heroId = message.value.heroId;
    const dragonId = message.value.dragonId;

    const items = [
      &#123; id: 1, name: &#39;Mythical Sword&#39; &#125;,
      &#123; id: 2, name: &#39;Key to Dungeon&#39; &#125;,
    ];

    return &#123;
      headers: &#123;
        realm
      &#125;,
      key: heroId,
      value: items
    &#125;
  &#125;
&#125;</code></pre><p>Additionally, messages passed in this format can also contain custom headers set in the <code>headers</code> hash property. Header hash property values must be either of type <code>string</code> or type <code>Buffer</code>.</p>

<span class="filename">
  {{ 'hero.controller' | extension: appf8a2ed2623cdbb06ed3e6ae1fc12b7824ddd0614.isJsActive }}
<app-tabs #appf8a2ed2623cdbb06ed3e6ae1fc12b7824ddd0614></app-tabs>
</span><pre><code class="language-typescript">
@Controller()
export class HeroService &#123;
  @MessagePattern(&#39;hero.kill.dragon&#39;)
  killDragon(message: any): any &#123;
    const realm = &#39;Nest&#39;;
    const heroId = message.value.heroId;
    const dragonId = message.value.dragonId;

    const items = [
      &#123; id: 1, name: &#39;Mythical Sword&#39; &#125;,
      &#123; id: 2, name: &#39;Key to Dungeon&#39; &#125;,
    ];

    return &#123;
      headers: &#123;
        kafka_nestRealm: realm
      &#125;,
      key: heroId,
      value: items
    &#125;
  &#125;
&#125;</code></pre><h4 appAnchor id="naming-conventions"><span>Naming conventions</span></h4>
<p>The Kafka microservice components append a description of their respective role onto the <code>client.clientId</code> and <code>consumer.groupId</code> options to prevent collisions between Nest microservice client and server components. By default the <code>ClientKafka</code> components append <code>-client</code> and the <code>ServerKafka</code> components append <code>-server</code> to both of these options.</p>

<span class="filename">
  {{ 'main' | extension: appeb9762d8c6d8dc70e672e95be974fc10ee4d40a4.isJsActive }}
<app-tabs #appeb9762d8c6d8dc70e672e95be974fc10ee4d40a4></app-tabs>
</span><pre><code class="language-typescript">
const app = await NestFactory.createMicroservice(ApplicationModule, &#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      clientId: &#39;hero&#39;, // hero-server
      brokers: [&#39;localhost:9092&#39;],
    &#125;,
    consumer: &#123;
      groupId: &#39;hero-consumer&#39; // hero-consumer-server
    &#125;,
  &#125;
&#125;);</code></pre>
<span class="filename">
  {{ 'hero.controller' | extension: app3baa7cd837bbbc790670ea7b9e9bc7a810415113.isJsActive }}
<app-tabs #app3baa7cd837bbbc790670ea7b9e9bc7a810415113></app-tabs>
</span><pre><code class="language-typescript">
@Client(&#123;
  transport: Transport.KAFKA,
  options: &#123;
    client: &#123;
      clientId: &#39;hero&#39;, // hero-client
      brokers: [&#39;localhost:9092&#39;],
    &#125;,
    consumer: &#123;
      groupId: &#39;hero-consumer&#39; // hero-consumer-client
    &#125;
  &#125;
&#125;)
client: ClientKafka;</code></pre><blockquote class="
info "><strong>Hint</strong> Kafka client and consumer naming conventions can be customized by extending <code>ClientKafka</code> and <code>KafkaServer</code> in your own custom provider and overriding the constructor.
</blockquote>
<p>Since the Kafka microservice message pattern utilizes two topics for the request and reply channels, a reply pattern should be derived from the request topic. By default, the name of the reply topic is the composite of the request topic name with <code>.reply</code> appended.</p>

<span class="filename">
  {{ 'hero.controller' | extension: app35b199337ee5455724e4638c50add8da701fa5ad.isJsActive }}
<app-tabs #app35b199337ee5455724e4638c50add8da701fa5ad></app-tabs>
</span><pre><code class="language-typescript">
onModuleInit() &#123;
  this.client.subscribeToResponseOf(&#39;hero.get&#39;); // hero.get.reply
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> Kafka reply topic naming conventions can be customized by extending <code>ClientKafka</code> in your own custom provider and overriding the <code>getResponsePatternName</code> method.
</blockquote>

</div>

